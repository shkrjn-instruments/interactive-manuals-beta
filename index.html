<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Module Interactive Manual</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Start Screen Styles */
        .start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 40px);
            gap: 30px;
        }

        .start-button {
            background-color: #444444;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            width: 300px;
            max-width: 90vw;
            /* Prevent text selection on touch devices */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts on iOS */
            -webkit-touch-callout: none;
            /* Prevent tap highlighting */
            -webkit-tap-highlight-color: transparent;
        }

        .start-button:hover {
            background-color: #555555;
            transform: translateY(-1px);
        }

        .start-button:active {
            transform: translateY(0);
            background-color: #333333;
        }

        /* Demo Container Styles */
        .demo-container {
            display: none;
            width: 100%;
            max-width: 1400px;
        }

        .demo-container.active {
            display: block;
        }

        /* Sample and Hold Demo Styles (from existing code) */
        .main-container {
            display: flex;
            align-items: flex-start;
            gap: 30px;
            margin-bottom: 30px;
            width: 100%;
            justify-content: center;
        }

        .oscilloscope-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 2;
        }

        .container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .labels {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            height: 400px;
            font-size: 16px;
            font-weight: bold;
            position: relative;
            margin-right: 10px;
            min-width: 60px;
        }
        
        .labels > div {
            position: absolute;
            right: 0;
        }
        
        .labels > div:nth-child(1) {
            top: 25%;
            transform: translateY(-50%);
        }
        
        .labels > div:nth-child(2) {
            top: 50%;
            transform: translateY(-50%);
        }
        
        .labels > div:nth-child(3) {
            top: 75%;
            transform: translateY(-50%);
        }
        
        /* Special case for 5 labels (duophonic mode) */
        .labels.five-labels > div:nth-child(1) {
            top: 10%;
        }
        
        .labels.five-labels > div:nth-child(2) {
            top: 30%;
        }
        
        .labels.five-labels > div:nth-child(3) {
            top: 50%;
        }
        
        .labels.five-labels > div:nth-child(4) {
            top: 70%;
        }
        
        .labels.five-labels > div:nth-child(5) {
            top: 90%;
        }

        .label-input {
            color: #00ffff;
        }

        .label-input-blue {
            color: #0080ff;
        }

        .label-trig {
            color: #0080ff;
        }

        .label-trig-orange {
            color: #ff8800;
        }

        .label-output {
            color: #ff00ff;
        }

        .label-output-yellow {
            color: #ffff00;
        }

        canvas {
            background-color: #000000;
            border: 2px solid #444444;
            border-radius: 4px;
            width: 100%;
            max-width: 800px;
            height: auto;
        }

        .controls {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 60px;
            margin: 0 auto;
            margin-bottom: 20px;
        }

        .button {
            background-color: #0080ff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .button:hover {
            background-color: #0099ff;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
            background-color: #0066cc;
        }

        .smpl-button {
            position: absolute;
            top: 0;
            left: 365px;
            transform: translateX(-50%);
        }

        .track-button {
            position: absolute;
            top: 0;
            left: 515px;
            transform: translateX(-50%);
        }

        .track-button:hover {
            background-color: #0099ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .track-button:active {
            transform: translateX(-50%) translateY(0);
            background-color: #0066cc;
        }

        .smpl-button:hover {
            background-color: #0099ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .smpl-button:active {
            transform: translateX(-50%) translateY(0);
            background-color: #0066cc;
        }

        .duo-button {
            background-color: #8800ff;
            position: absolute;
            top: 0;
            left: 439px;
            transform: translateX(-50%);
        }

        .duo-button:hover {
            background-color: #9922ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .duo-button:active {
            background-color: #6600cc;
            transform: translateX(-50%) translateY(0);
        }

        .mode-controls {
            position: relative;
            left: 138px;
            transform: translateX(-50%);
            margin-top: 20px;
        }

        .mode-button {
            background-color: #444444;
            padding: 10px 20px;
            font-size: 14px;
        }

        .mode-button:hover {
            background-color: #555555;
        }

        .mode-button:active {
            background-color: #333333;
        }

        .title {
            margin-bottom: 30px;
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Back to Menu Button */
        .back-button {
            background-color: #666666;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.1s;
            margin-bottom: 20px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .back-button:hover {
            background-color: #777777;
            transform: translateY(-1px);
        }

        .back-button:active {
            transform: translateY(0);
            background-color: #555555;
        }

        /* Full Wave Rectifier Specific Styles */
        .slider-container {
            position: absolute;
            right: -60px;
            top: 50%;
            transform: translateY(-50%);
            height: 300px;
            width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .slider-track {
            width: 4px;
            height: 100%;
            background-color: #444444;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .slider-thumb {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #0080ff;
            border-radius: 50%;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
            transition: background-color 0.1s;
        }

        .slider-thumb:active {
            cursor: grabbing;
            background-color: #0099ff;
        }

        .slider-thumb.dragging {
            background-color: #0099ff;
        }

        .waveform-button {
            background-color: #444444;
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.1s;
            margin-top: 20px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .waveform-button:hover {
            background-color: #555555;
            transform: translateY(-1px);
        }

        .waveform-button:active {
            transform: translateY(0);
            background-color: #333333;
        }

        /* LED styles */
        .led-container {
            position: absolute;
            right: -60px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .led {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #222222;
            border: 2px solid #444444;
            transition: all 0.1s;
        }

        .led.active-blue {
            background-color: #0080ff;
            border-color: #0080ff;
            box-shadow: 0 0 10px #0080ff;
        }

        .led.active-cyan {
            background-color: #00ffff;
            border-color: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        .led.active-purple {
            background-color: #ff00ff;
            border-color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }

        .slider-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .slider-label.top {
            top: -25px;
        }
        
        .slider-label.bottom {
            bottom: -25px;
        }

        /* Responsive design */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            
            .container {
                gap: 10px;
            }
            
            .labels {
                font-size: 14px;
            }

            .slider-container {
                right: -50px;
            }

            .led-container {
                right: -50px;
            }
        }
        
        @media (max-width: 600px) {
            .title {
                font-size: 18px;
                margin-bottom: 15px;
            }
            
            .labels {
                font-size: 12px;
                margin-right: 5px;
                min-width: 45px;
            }
            
            .button {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            .controls {
                height: 50px;
            }
            
            .smpl-button {
                left: 35%;
            }
            
            .track-button {
                left: 65%;
            }
            
            .duo-button {
                left: 50%;
            }
            
            .mode-controls {
                left: 50%;
                transform: translateX(-50%);
                margin-top: 15px;
            }
            
            .mode-button {
                font-size: 12px;
                padding: 8px 16px;
            }
            
            .info-trigger, .pdf-link {
                font-size: 14px;
            }

            .slider-container {
                right: -40px;
                height: 250px;
            }

            .led-container {
                right: -40px;
                gap: 15px;
            }

            .led {
                width: 25px;
                height: 25px;
            }

            .slider-thumb {
                width: 25px;
                height: 25px;
            }

            .waveform-button {
                font-size: 14px;
                padding: 8px 20px;
            }

            .slider-label {
                font-size: 12px;
            }
            
            .container {
                gap: 10px;
            }
        }
        
        @media (max-width: 350px) {
            .controls {
                height: auto;
                display: flex;
                flex-direction: column;
                gap: 10px;
                padding: 0 20px;
            }
            
            .button {
                position: static !important;
                transform: none !important;
                width: 100%;
                max-width: 200px;
                margin: 0 auto;
            }
            
            .mode-controls {
                margin-top: 10px;
            }
            
            .labels {
                font-size: 11px;
            }
        }

        /* Popup System */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup-window {
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffffff;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80%;
            padding: 30px;
            position: relative;
            overflow-y: auto;
        }

        .popup-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .popup-close:hover {
            color: #ff4444;
        }

        .popup-content {
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .popup-content strong {
            font-weight: bold;
        }

        .popup-navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .popup-nav-button {
            background-color: #444444;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.1s;
            font-family: 'Courier New', monospace;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .popup-nav-button:hover {
            background-color: #555555;
            transform: translateY(-1px);
        }

        .popup-nav-button:active {
            transform: translateY(0);
            background-color: #333333;
        }

        .popup-nav-button:disabled {
            background-color: #222222;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        .info-trigger {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #ffffff;
            text-decoration: underline;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .info-trigger:hover {
            color: #00ffff;
            opacity: 1;
        }
        
        .pdf-link {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #ffffff;
            text-decoration: underline;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        
        .pdf-link:hover {
            color: #00ffff;
            opacity: 1;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        .text-block {
            display: none;
        }

        .text-block.active {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <button class="start-button" id="sampleHoldBtn">Sample and Hold</button>
        <button class="start-button" id="flipFlopBtn">Flip Flop Clock Divider / Comparator</button>
        <button class="start-button" id="fullWaveBtn">Full Wave Rectifier</button>
    </div>

    <!-- Sample and Hold Demo Container -->
    <div class="demo-container" id="sampleHoldDemo">
        <button class="back-button" id="backFromSH">Back to Menu</button>
        <div class="title" id="pageTitle">Sample/Track and Hold Demonstration</div>
        
        <div class="main-container" id="mainContainer">
            <div class="oscilloscope-section">
                <div class="container">
                    <div class="labels" id="labelContainer">
                        <div class="label-input">input</div>
                        <div class="label-trig">trig</div>
                        <div class="label-output">output</div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="shOscilloscope" width="800" height="400"></canvas>
                        <div class="info-trigger" id="shInfoTrigger">info</div>
                        <a class="pdf-link" href="https://static1.squarespace.com/static/62c31debe11bcc2b1ade537b/t/646bc355b89fc210cd31f93e/1684783957746/shkrjn+duophonic+distribution+Manual.pdf" target="_blank" rel="noopener noreferrer">pdf</a>
                    </div>
                </div>
                
                <div class="controls" id="controlsContainer">
                    <button class="button smpl-button" id="trigButton">SMPL</button>
                    <button class="button track-button" id="trackButton">TRACK</button>
                </div>
                
                <div class="mode-controls">
                    <button class="button mode-button" id="modeButton">Switch to Duophonic Mode</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Full Wave Rectifier Demo Container -->
    <div class="demo-container" id="fullWaveDemo">
        <button class="back-button" id="backFromFW">Back to Menu</button>
        <div class="title">Full Wave Rectifier Demonstration</div>
        
        <div class="main-container">
            <div class="oscilloscope-section">
                <div class="container">
                    <div class="labels">
                        <div class="label-input-blue">input</div>
                        <div class="label-output">output</div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="fwOscilloscope" width="800" height="400"></canvas>
                        <div class="info-trigger" id="fwInfoTrigger">info</div>
                        <a class="pdf-link" href="https://static1.squarespace.com/static/62c31debe11bcc2b1ade537b/t/646bc355b89fc210cd31f93e/1684783957746/shkrjn+duophonic+distribution+Manual.pdf" target="_blank" rel="noopener noreferrer">pdf</a>
                        
                        <div class="slider-container">
                            <div class="slider-track" id="sliderTrack">
                                <div class="slider-thumb" id="sliderThumb" style="top: 50%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button class="waveform-button" id="waveformButton">Waveform</button>
            </div>
        </div>
    </div>

    <!-- Flip Flop Demo Container -->
    <div class="demo-container" id="flipFlopDemo">
        <button class="back-button" id="backFromFF">Back to Menu</button>
        <div class="title" id="ffPageTitle">Flip Flop Clock Divider Demonstration</div>
        
        <div class="main-container">
            <div class="oscilloscope-section">
                <div class="container">
                    <div class="labels" id="ffLabelContainer">
                        <div class="label-trig">trig</div>
                        <div class="label-input">flip</div>
                        <div class="label-output">flop</div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="ffOscilloscope" width="800" height="400"></canvas>
                        <div class="info-trigger" id="ffInfoTrigger">info</div>
                        <a class="pdf-link" href="https://static1.squarespace.com/static/62c31debe11bcc2b1ade537b/t/646bc355b89fc210cd31f93e/1684783957746/shkrjn+duophonic+distribution+Manual.pdf" target="_blank" rel="noopener noreferrer">pdf</a>
                        
                        <!-- LED indicators for flip flop mode -->
                        <div class="led-container" id="ffLedContainer">
                            <div class="led" id="ledTrig"></div>
                            <div class="led" id="ledFlip"></div>
                            <div class="led" id="ledFlop"></div>
                        </div>
                        
                        <!-- Sliders for comparator mode -->
                        <div class="slider-container" id="ffThreshSlider" style="display: none;">
                            <div class="slider-label bottom">thresh</div>
                            <div class="slider-track">
                                <div class="slider-thumb" id="threshThumb" style="top: 50%;"></div>
                            </div>
                        </div>
                        
                        <div class="slider-container" id="ffOffsetSlider" style="display: none; right: -110px;">
                            <div class="slider-label top">offset</div>
                            <div class="slider-track">
                                <div class="slider-thumb" id="offsetThumb" style="top: 50%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls" id="ffControlsContainer">
                    <button class="button smpl-button" id="ffTrigButton">TRIG</button>
                </div>
                
                <div class="mode-controls">
                    <button class="button mode-button" id="ffModeButton">Switch to Comparator Mode</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Popup System for Sample/Hold -->
    <div class="popup-overlay" id="shPopupOverlay" style="display: none;">
        <div class="popup-window">
            <button class="popup-close" id="shPopupClose">×</button>
            <div class="popup-content">
                <!-- Single Mode Text Blocks -->
                <div class="text-block active" id="singleText1">
                    <p>Think of a sample and hold as an analog memory circuit.</p>
                    <p>There is a signal input, trigger input, and signal output. When a trigger is applied to the trigger input, the instantaneous level of the input voltage is relayed to the signal output. This voltage is held until another trigger is received, which causes the process to repeat. A sample and hold is a great way to turn smooth and continuous modulation into stepwise modulation.</p>
                    <p>Click the <strong>smpl</strong> button and watch the purple output trace.</p>
                </div>
                
                <div class="text-block" id="singleText2">
                    <p>A track and hold responds to gates rather than triggers.</p>
                    <p>When a gate high is applied to the trigger input, the signal output will perfectly follow the signal input. When the gate goes low, the output signal will hold its most recent value until another trigger or gate is applied to the trigger input.</p>
                    <p>Click and hold the <strong>track</strong> button and watch the purple output trace. Notice the return back to sample and hold behavior after its release.</p>
                </div>
                
                <div class="text-block" id="singleText3">
                    <p>Combining both of these functions into one module allows for dynamic modulation by switching between stepwise and smooth modulation.</p>
                </div>

                <!-- Duophonic Mode Text Blocks -->
                <div class="text-block" id="duoText1">
                    <p>Duophonic Distribution combines two sample and holds and allows them to be triggered in an alternating manner.</p>
                    <p>This allows two distinct, but related, modulation sources to be derived from the same input signal. It can also be used to create true two voice polyphony by splitting a single pitch CV sequence between two oscillators.</p>
                </div>
                
                <div class="text-block" id="duoText2">
                    <p>Click the <strong>Duo</strong> button and watch the two output traces adjust in an alternating manner. To mimic this behavior IRL, apply a gate to the input of Duophonic Distribution's Flip Flop style clock divider.</p>
                </div>
            </div>
            
            <div class="popup-navigation">
                <button class="popup-nav-button" id="shPrevButton" disabled><< prev</button>
                <button class="popup-nav-button" id="shNextButton">next >></button>
            </div>
        </div>
    </div>

    <!-- Popup System for Full Wave Rectifier -->
    <div class="popup-overlay" id="fwPopupOverlay" style="display: none;">
        <div class="popup-window">
            <button class="popup-close" id="fwPopupClose">×</button>
            <div class="popup-content">
                <div class="text-block active" id="fwText1">
                    <p>A full wave rectifier is an absolute value circuit. There is an input and an output. Positive values are passed from the input to the output unchanged, while negative values are inverted to their respective positive values.</p>
                    <p>Adjust the offset slider and watch what happens to the output waveform as the input waveform becomes more or less negative.</p>
                </div>
                
                <div class="text-block" id="fwText2">
                    <p>Full wave rectifiers can act as frequency doublers when they process bipolar triangle waves.</p>
                    <p>They can also act as triangle converters when they are used to process sawtooth waveforms.</p>
                    <p>They can also simply be used to convert bipolar waveforms into unipolar waveforms.</p>
                </div>
            </div>
            
            <div class="popup-navigation">
                <button class="popup-nav-button" id="fwPrevButton" disabled><< prev</button>
                <button class="popup-nav-button" id="fwNextButton">next >></button>
            </div>
        </div>
    </div>

    <!-- Popup System for Flip Flop -->
    <div class="popup-overlay" id="ffPopupOverlay" style="display: none;">
        <div class="popup-window">
            <button class="popup-close" id="ffPopupClose">×</button>
            <div class="popup-content">
                <!-- Flip Flop Mode Text Blocks -->
                <div class="text-block active" id="ffText1">
                    <p>A flip flop circuit is a clock divider with two outputs. Each output divides the input clock by two and maintains an opposite phase relationship with the other channel. We will call one output "flip" and the other "flop".</p>
                    <p>Initially "flip" is logic high while "flop" is logic low. When a trigger is applied to the input, "flip" goes low, while "flop" goes high. The state of the two outputs continue to alternate as successive triggers are applied to the input.</p>
                </div>
                
                <div class="text-block" id="ffText2">
                    <p>Click the trigger button and watch the flip and flop traces alternate on the oscilloscope and via the LEDs on the right.</p>
                    <p>This kind of clock divider does not need a continuous or steady clock. Each trigger will make it change states and then it will simply wait for the next trigger.</p>
                </div>

                <!-- Comparator Mode Text Blocks -->
                <div class="text-block" id="compText1">
                    <p>A comparator is a logic circuit with an input signal, a threshold level, and a logic output. When the input signal is greater than the threshold level, the output is a logic high. When the input signal is lower than the threshold level, the output is a logic low.</p>
                    <p>Comparators are often used for pulse width modulation. Adjust the threshold level via the slider on the right and watch what happens to the output waveform.</p>
                </div>
                
                <div class="text-block" id="compText2">
                    <p>The comparator on Duophonic Distribution has a fixed internal threshold level. But because everything is relative, a variable threshold can easily be patched by mixing your input waveform with an adjustable DC offset before it is applied to the input of the comparator.</p>
                    <p>Adjust the offset slider and watch how it affects the output waveform. Alternate between adjusting the threshold and offset slider. Note how they have the same affect on the output.</p>
                </div>
            </div>
            
            <div class="popup-navigation">
                <button class="popup-nav-button" id="ffPrevButton" disabled><< prev</button>
                <button class="popup-nav-button" id="ffNextButton">next >></button>
            </div>
        </div>
    </div>

    <script>
        // Start Screen Navigation
        const startScreen = document.getElementById('startScreen');
        const sampleHoldBtn = document.getElementById('sampleHoldBtn');
        const flipFlopBtn = document.getElementById('flipFlopBtn');
        const fullWaveBtn = document.getElementById('fullWaveBtn');
        
        const sampleHoldDemo = document.getElementById('sampleHoldDemo');
        const fullWaveDemo = document.getElementById('fullWaveDemo');
        const flipFlopDemo = document.getElementById('flipFlopDemo');
        
        const backFromSH = document.getElementById('backFromSH');
        const backFromFW = document.getElementById('backFromFW');
        const backFromFF = document.getElementById('backFromFF');

        function showDemo(demoId) {
            startScreen.style.display = 'none';
            sampleHoldDemo.classList.remove('active');
            fullWaveDemo.classList.remove('active');
            flipFlopDemo.classList.remove('active');
            
            document.getElementById(demoId).classList.add('active');
            
            // Initialize the appropriate demo
            if (demoId === 'sampleHoldDemo' && !window.shInitialized) {
                initSampleHoldDemo();
                window.shInitialized = true;
            } else if (demoId === 'fullWaveDemo' && !window.fwInitialized) {
                initFullWaveRectifierDemo();
                window.fwInitialized = true;
            } else if (demoId === 'flipFlopDemo' && !window.ffInitialized) {
                initFlipFlopDemo();
                window.ffInitialized = true;
            }
        }

        function backToMenu() {
            startScreen.style.display = 'flex';
            sampleHoldDemo.classList.remove('active');
            fullWaveDemo.classList.remove('active');
            flipFlopDemo.classList.remove('active');
        }

        // Touch and click handlers
        const addTouchAndClickListener = (element, handler) => {
            element.addEventListener('click', handler);
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                handler(e);
            });
        };

        addTouchAndClickListener(sampleHoldBtn, () => showDemo('sampleHoldDemo'));
        addTouchAndClickListener(fullWaveBtn, () => showDemo('fullWaveDemo'));
        addTouchAndClickListener(flipFlopBtn, () => showDemo('flipFlopDemo'));
        addTouchAndClickListener(backFromSH, backToMenu);
        addTouchAndClickListener(backFromFW, backToMenu);
        addTouchAndClickListener(backFromFF, backToMenu);

        // Sample and Hold Demo Code
        function initSampleHoldDemo() {
            const canvas = document.getElementById('shOscilloscope');
            const ctx = canvas.getContext('2d');
            const trigButton = document.getElementById('trigButton');
            const trackButton = document.getElementById('trackButton');
            const modeButton = document.getElementById('modeButton');
            const pageTitle = document.getElementById('pageTitle');
            const labelContainer = document.getElementById('labelContainer');
            const controlsContainer = document.getElementById('controlsContainer');
            
            // Responsive canvas sizing
            function setCanvasSize() {
                const container = canvas.parentElement;
                const labelWidth = 80; // Space for labels
                const extraSpace = 120; // Space for labels + padding
                const maxWidth = Math.min(800, window.innerWidth - extraSpace);
                const aspectRatio = 2;
                
                canvas.width = maxWidth;
                canvas.height = maxWidth / aspectRatio;
                
                // Update label container height to match canvas
                const labels = labelContainer;
                if (labels) {
                    labels.style.height = canvas.height + 'px';
                }
            }
            
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            // Popup system elements
            const popupOverlay = document.getElementById('shPopupOverlay');
            const popupClose = document.getElementById('shPopupClose');
            const infoTrigger = document.getElementById('shInfoTrigger');
            const prevButton = document.getElementById('shPrevButton');
            const nextButton = document.getElementById('shNextButton');
            
            // Popup state
            let popupMode = 'single';
            let currentTextIndex = 0;
            let hasSeenSinglePopup = false;
            let hasSeenDuoPopup = false;
            
            const singleTextBlocks = ['singleText1', 'singleText2', 'singleText3'];
            const duoTextBlocks = ['duoText1', 'duoText2'];
            
            let currentEventListeners = {
                trigButton: null,
                trackButton: null,
                duoButton: null,
                trackMouseUp: null,
                trackMouseLeave: null,
                trackTouchEnd: null
            };
            
            function showTextBlock(index) {
                document.querySelectorAll('.text-block').forEach(block => {
                    block.classList.remove('active');
                });
                
                const blocks = popupMode === 'single' ? singleTextBlocks : duoTextBlocks;
                if (index >= 0 && index < blocks.length) {
                    document.getElementById(blocks[index]).classList.add('active');
                }
                
                prevButton.disabled = index === 0;
                nextButton.disabled = index === blocks.length - 1;
                currentTextIndex = index;
            }
            
            function showPopup() {
                popupOverlay.style.display = 'flex';
                currentTextIndex = 0;
                showTextBlock(0);
            }
            
            function hidePopup() {
                popupOverlay.style.display = 'none';
                
                if (popupMode === 'single') {
                    hasSeenSinglePopup = true;
                } else {
                    hasSeenDuoPopup = true;
                }
            }
            
            addTouchAndClickListener(popupClose, hidePopup);
            addTouchAndClickListener(infoTrigger, showPopup);
            
            addTouchAndClickListener(prevButton, () => {
                if (currentTextIndex > 0) {
                    showTextBlock(currentTextIndex - 1);
                }
            });
            
            addTouchAndClickListener(nextButton, () => {
                const maxIndex = (popupMode === 'single' ? singleTextBlocks.length : duoTextBlocks.length) - 1;
                if (currentTextIndex < maxIndex) {
                    showTextBlock(currentTextIndex + 1);
                }
            });
            
            popupOverlay.addEventListener('click', (e) => {
                if (e.target === popupOverlay) {
                    hidePopup();
                }
            });
            
            popupOverlay.addEventListener('touchend', (e) => {
                if (e.target === popupOverlay) {
                    e.preventDefault();
                    hidePopup();
                }
            });
            
            let currentMode = 'single';
            let time = 0;
            let sampledValue = 0;
            let sampledValue1 = 0;
            let sampledValue2 = 0;
            let triggerActive = false;
            let triggerActive1 = false;
            let triggerActive2 = false;
            let triggerTime = 0;
            let triggerTime1 = 0;
            let triggerTime2 = 0;
            let trackActive = false;
            let alternateFlag = true;
            const triggerDuration = 6.25; // Longer duration for better LED visibility in flip flop // Shortened from 50 to 12.5 (1/4 of original)
            
            let width = canvas.width;
            let height = canvas.height;
            let centerY = height / 2;
            let centerX = width / 2;
            
            const triangleFreq = 0.002;
            let amplitude = height * 0.25;
            
            window.addEventListener('resize', () => {
                width = canvas.width;
                height = canvas.height;
                centerY = height / 2;
                centerX = width / 2;
                amplitude = height * 0.25;
            });
            
            const triggerEvents = [];
            const trackEvents = [];
            const triggerEvents1 = [];
            const triggerEvents2 = [];
            let currentSampledValue = 0;
            let lastTriggerTime = -1000;
            let trackStartTime = -1000;
            
            let lastDuoClickTime = 0;
            let lastSmplClickTime = 0;
            const minClickInterval = 100;
            
            let touchProcessing = false;
            
            function getTriangleValue(t) {
                const phase = (t * triangleFreq) % 1;
                let value;
                if (phase < 0.5) {
                    value = phase * 2;
                } else {
                    value = 2 - (phase * 2);
                }
                return (value - 0.5) * 2;
            }
            
            function drawGrid() {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.75)';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.stroke();
            }
            
            function cleanupEventListeners() {
                if (currentEventListeners.trackMouseUp) {
                    document.removeEventListener('mouseup', currentEventListeners.trackMouseUp);
                    currentEventListeners.trackMouseUp = null;
                }
                if (currentEventListeners.trackMouseLeave) {
                    document.removeEventListener('mouseleave', currentEventListeners.trackMouseLeave);
                    currentEventListeners.trackMouseLeave = null;
                }
                if (currentEventListeners.trackTouchEnd) {
                    document.removeEventListener('touchend', currentEventListeners.trackTouchEnd);
                    currentEventListeners.trackTouchEnd = null;
                }
            }
            
            function switchMode() {
                cleanupEventListeners();
                
                if (currentMode === 'single') {
                    currentMode = 'duo';
                    popupMode = 'duo';
                    pageTitle.textContent = 'Duophonic Sample and Hold Demonstration';
                    modeButton.textContent = 'Switch to Single Mode';
                    
                    labelContainer.innerHTML = `
                        <div class="label-input">input</div>
                        <div class="label-trig">trig 1</div>
                        <div class="label-trig-orange">trig 2</div>
                        <div class="label-output">output 1</div>
                        <div class="label-output-yellow">output 2</div>
                    `;
                    labelContainer.classList.add('five-labels');
                    
                    controlsContainer.innerHTML = `
                        <button class="button duo-button" id="duoButton">DUO</button>
                    `;
                    
                    const duoButton = document.getElementById('duoButton');
                    
                    const duoHandler = (e) => {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        
                        const currentTime = Date.now();
                        if (currentTime - lastDuoClickTime < minClickInterval) {
                            return;
                        }
                        lastDuoClickTime = currentTime;
                        
                        if (alternateFlag) {
                            triggerActive1 = true;
                            triggerTime1 = currentTime;
                        } else {
                            triggerActive2 = true;
                            triggerTime2 = currentTime;
                        }
                        alternateFlag = !alternateFlag;
                    };
                    
                    if ('ontouchstart' in window) {
                        duoButton.addEventListener('touchstart', duoHandler);
                    } else {
                        duoButton.addEventListener('click', duoHandler);
                    }
                    
                    currentEventListeners.duoButton = duoHandler;
                    
                    if (!hasSeenDuoPopup) {
                        showPopup();
                    }
                    
                } else {
                    currentMode = 'single';
                    popupMode = 'single';
                    pageTitle.textContent = 'Sample/Track and Hold Demonstration';
                    modeButton.textContent = 'Switch to Duophonic Mode';
                    
                    labelContainer.innerHTML = `
                        <div class="label-input">input</div>
                        <div class="label-trig">trig</div>
                        <div class="label-output">output</div>
                    `;
                    labelContainer.classList.remove('five-labels');
                    
                    controlsContainer.innerHTML = `
                        <button class="button smpl-button" id="trigButton">SMPL</button>
                        <button class="button track-button" id="trackButton">TRACK</button>
                    `;
                    
                    const newTrigButton = document.getElementById('trigButton');
                    const newTrackButton = document.getElementById('trackButton');
                    
                    const trigHandler = (e) => {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        
                        const currentTime = Date.now();
                        if (currentTime - lastSmplClickTime < minClickInterval) {
                            return;
                        }
                        lastSmplClickTime = currentTime;
                        
                        triggerActive = true;
                        triggerTime = currentTime;
                    };
                    
                    if ('ontouchstart' in window) {
                        newTrigButton.addEventListener('touchstart', trigHandler);
                    } else {
                        newTrigButton.addEventListener('click', trigHandler);
                    }
                    
                    const trackStartHandler = (e) => {
                        e.preventDefault();
                        trackActive = true;
                        trackStartTime = time;
                        trackEvents.push({
                            startTime: time,
                            endTime: null
                        });
                    };
                    
                    const trackEndHandler = (e) => {
                        if (e) e.preventDefault();
                        if (trackActive) {
                            trackActive = false;
                            if (trackEvents.length > 0) {
                                const currentEvent = trackEvents[trackEvents.length - 1];
                                if (currentEvent.endTime === null) {
                                    currentEvent.endTime = time;
                                    sampledValue = getTriangleValue(time);
                                }
                            }
                        }
                    };
                    
                    newTrackButton.addEventListener('mousedown', trackStartHandler);
                    newTrackButton.addEventListener('touchstart', trackStartHandler);
                    
                    currentEventListeners.trackMouseUp = trackEndHandler;
                    currentEventListeners.trackTouchEnd = trackEndHandler;
                    currentEventListeners.trackMouseLeave = trackEndHandler;
                    
                    document.addEventListener('mouseup', currentEventListeners.trackMouseUp);
                    document.addEventListener('touchend', currentEventListeners.trackTouchEnd);
                    document.addEventListener('mouseleave', currentEventListeners.trackMouseLeave);
                }
            }
            
            function drawSingleMode() {
                const currentTime = Date.now();
                
                if (triggerActive && (currentTime - triggerTime) < 16) {
                    triggerEvents.push({
                        time: time,
                        duration: triggerDuration
                    });
                    
                    currentSampledValue = getTriangleValue(time);
                    sampledValue = currentSampledValue;
                    lastTriggerTime = time;
                    
                    const cutoffTime = time - width * 2;
                    triggerEvents.splice(0, triggerEvents.findIndex(event => event.time > cutoffTime));
                    trackEvents.splice(0, trackEvents.findIndex(event => event.startTime > cutoffTime));
                }
                
                if (triggerActive && (currentTime - triggerTime) > triggerDuration) {
                    triggerActive = false;
                }
                
                ctx.lineWidth = 2;
                
                // Draw input waveform
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    const inputValue = getTriangleValue(t);
                    const inputY = centerY - (inputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, inputY);
                    } else {
                        ctx.lineTo(x, inputY);
                    }
                }
                ctx.stroke();
                
                // Draw trigger trace
                ctx.strokeStyle = '#0080ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let triggerState = false;
                    
                    for (const event of triggerEvents) {
                        const timeSinceTrigger = t - event.time;
                        if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                            triggerState = true;
                            break;
                        }
                    }
                    
                    if (!triggerState) {
                        for (const event of trackEvents) {
                            if (t >= event.startTime && (event.endTime === null || t <= event.endTime)) {
                                triggerState = true;
                                break;
                            }
                        }
                    }
                    
                    const triggerY = triggerState ? (height / 3) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, triggerY);
                    } else {
                        ctx.lineTo(x, triggerY);
                    }
                }
                ctx.stroke();
                
                // Draw output trace
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let outputValue = 0;
                    
                    let inTrackPeriod = false;
                    let activeTrackEvent = null;
                    for (const event of trackEvents) {
                        if (t >= event.startTime && (event.endTime === null || t <= event.endTime)) {
                            inTrackPeriod = true;
                            activeTrackEvent = event;
                            break;
                        }
                    }
                    
                    if (inTrackPeriod && activeTrackEvent) {
                        if (t <= time) {
                            outputValue = getTriangleValue(t);
                        } else {
                            let preTrackValue = 0;
                            let mostRecentTime = -Infinity;
                            
                            for (const trigEvent of triggerEvents) {
                                if (trigEvent.time < activeTrackEvent.startTime && trigEvent.time > mostRecentTime) {
                                    mostRecentTime = trigEvent.time;
                                    preTrackValue = getTriangleValue(trigEvent.time);
                                }
                            }
                            
                            for (const prevTrackEvent of trackEvents) {
                                if (prevTrackEvent.endTime !== null && 
                                    prevTrackEvent.endTime < activeTrackEvent.startTime && 
                                    prevTrackEvent.endTime > mostRecentTime) {
                                    mostRecentTime = prevTrackEvent.endTime;
                                    preTrackValue = getTriangleValue(prevTrackEvent.endTime);
                                }
                            }
                            
                            outputValue = preTrackValue;
                        }
                    } else {
                        let mostRecentTime = -Infinity;
                        let mostRecentValue = 0;
                        
                        for (const event of triggerEvents) {
                            if (event.time <= t && event.time > mostRecentTime) {
                                mostRecentTime = event.time;
                                mostRecentValue = getTriangleValue(event.time);
                            }
                        }
                        
                        for (const event of trackEvents) {
                            if (event.endTime !== null && event.endTime <= t && event.endTime > mostRecentTime) {
                                mostRecentTime = event.endTime;
                                mostRecentValue = getTriangleValue(event.endTime);
                            }
                        }
                        
                        outputValue = mostRecentValue;
                    }
                    
                    const outputY = centerY - (outputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, outputY);
                    } else {
                        ctx.lineTo(x, outputY);
                    }
                }
                ctx.stroke();
            }
            
            function drawDuoMode() {
                const currentTime = Date.now();
                
                if (triggerActive1 && (currentTime - triggerTime1) < 16) {
                    triggerEvents1.push({
                        time: time,
                        duration: triggerDuration
                    });
                    sampledValue1 = getTriangleValue(time);
                    
                    const cutoffTime = time - width * 2;
                    triggerEvents1.splice(0, triggerEvents1.findIndex(event => event ? event.time > cutoffTime : true));
                }
                
                if (triggerActive2 && (currentTime - triggerTime2) < 16) {
                    triggerEvents2.push({
                        time: time,
                        duration: triggerDuration
                    });
                    sampledValue2 = getTriangleValue(time);
                    
                    const cutoffTime = time - width * 2;
                    triggerEvents2.splice(0, triggerEvents2.findIndex(event => event ? event.time > cutoffTime : true));
                }
                
                if (triggerActive1 && (currentTime - triggerTime1) > triggerDuration) {
                    triggerActive1 = false;
                }
                if (triggerActive2 && (currentTime - triggerTime2) > triggerDuration) {
                    triggerActive2 = false;
                }
                
                ctx.lineWidth = 2;
                
                // Draw input waveform
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    const inputValue = getTriangleValue(t);
                    const inputY = centerY - (inputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, inputY);
                    } else {
                        ctx.lineTo(x, inputY);
                    }
                }
                ctx.stroke();
                
                // Draw trigger trace 1
                ctx.strokeStyle = '#0080ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let triggerState1 = false;
                    for (const event of triggerEvents1) {
                        const timeSinceTrigger = t - event.time;
                        if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                            triggerState1 = true;
                            break;
                        }
                    }
                    
                    const triggerY1 = triggerState1 ? (height / 3) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, triggerY1);
                    } else {
                        ctx.lineTo(x, triggerY1);
                    }
                }
                ctx.stroke();
                
                // Draw trigger trace 2
                ctx.strokeStyle = '#ff8800';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let triggerState2 = false;
                    for (const event of triggerEvents2) {
                        const timeSinceTrigger = t - event.time;
                        if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                            triggerState2 = true;
                            break;
                        }
                    }
                    
                    const triggerY2 = triggerState2 ? (height / 3) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, triggerY2);
                    } else {
                        ctx.lineTo(x, triggerY2);
                    }
                }
                ctx.stroke();
                
                // Draw output trace 1
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let outputValue1 = 0;
                    for (let i = triggerEvents1.length - 1; i >= 0; i--) {
                        const event = triggerEvents1[i];
                        if (event.time <= t) {
                            outputValue1 = getTriangleValue(event.time);
                            break;
                        }
                    }
                    
                    const outputY1 = centerY - (outputValue1 * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, outputY1);
                    } else {
                        ctx.lineTo(x, outputY1);
                    }
                }
                ctx.stroke();
                
                // Draw output trace 2
                ctx.strokeStyle = '#ffff00';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let outputValue2 = 0;
                    for (let i = triggerEvents2.length - 1; i >= 0; i--) {
                        const event = triggerEvents2[i];
                        if (event.time <= t) {
                            outputValue2 = getTriangleValue(event.time);
                            break;
                        }
                    }
                    
                    const outputY2 = centerY - (outputValue2 * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, outputY2);
                    } else {
                        ctx.lineTo(x, outputY2);
                    }
                }
                ctx.stroke();
            }
            
            function draw() {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                
                drawGrid();
                
                if (currentMode === 'single') {
                    drawSingleMode();
                } else {
                    drawDuoMode();
                }
                
                time += 1;
                requestAnimationFrame(draw);
            }
            
            // Initial event listeners
            const initialTrigHandler = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                const currentTime = Date.now();
                if (currentTime - lastSmplClickTime < minClickInterval) {
                    return;
                }
                lastSmplClickTime = currentTime;
                
                triggerActive = true;
                triggerTime = currentTime;
            };
            
            if ('ontouchstart' in window) {
                trigButton.addEventListener('touchstart', initialTrigHandler);
            } else {
                trigButton.addEventListener('click', initialTrigHandler);
            }
            
            const initialTrackStartHandler = (e) => {
                e.preventDefault();
                trackActive = true;
                trackStartTime = time;
                trackEvents.push({
                    startTime: time,
                    endTime: null
                });
            };
            
            const initialTrackEndHandler = (e) => {
                if (e) e.preventDefault();
                if (trackActive) {
                    trackActive = false;
                    if (trackEvents.length > 0) {
                        const currentEvent = trackEvents[trackEvents.length - 1];
                        if (currentEvent.endTime === null) {
                            currentEvent.endTime = time;
                            sampledValue = getTriangleValue(time);
                        }
                    }
                }
            };
            
            trackButton.addEventListener('mousedown', initialTrackStartHandler);
            trackButton.addEventListener('touchstart', initialTrackStartHandler);
            
            currentEventListeners.trackMouseUp = initialTrackEndHandler;
            currentEventListeners.trackTouchEnd = initialTrackEndHandler;
            currentEventListeners.trackMouseLeave = initialTrackEndHandler;
            
            document.addEventListener('mouseup', currentEventListeners.trackMouseUp);
            document.addEventListener('touchend', currentEventListeners.trackTouchEnd);
            document.addEventListener('mouseleave', currentEventListeners.trackMouseLeave);
            
            modeButton.addEventListener('click', switchMode);
            modeButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                switchMode();
            });
            
            showPopup();
            draw();
        }

        // Full Wave Rectifier Demo Code
        function initFullWaveRectifierDemo() {
            const canvas = document.getElementById('fwOscilloscope');
            const ctx = canvas.getContext('2d');
            const waveformButton = document.getElementById('waveformButton');
            const sliderTrack = document.getElementById('sliderTrack');
            const sliderThumb = document.getElementById('sliderThumb');
            
            // Responsive canvas sizing
            function setCanvasSize() {
                const container = canvas.parentElement;
                const extraSpace = 180; // Extra space for slider + labels
                const maxWidth = Math.min(800, window.innerWidth - extraSpace);
                const aspectRatio = 2;
                
                canvas.width = maxWidth;
                canvas.height = maxWidth / aspectRatio;
                
                // Update label container height to match canvas
                const labels = document.querySelector('#fullWaveDemo .labels');
                if (labels) {
                    labels.style.height = canvas.height + 'px';
                }
            }
            
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            // Popup system
            const popupOverlay = document.getElementById('fwPopupOverlay');
            const popupClose = document.getElementById('fwPopupClose');
            const infoTrigger = document.getElementById('fwInfoTrigger');
            const prevButton = document.getElementById('fwPrevButton');
            const nextButton = document.getElementById('fwNextButton');
            
            let currentTextIndex = 0;
            const textBlocks = ['fwText1', 'fwText2'];
            
            function showTextBlock(index) {
                document.querySelectorAll('#fwPopupOverlay .text-block').forEach(block => {
                    block.classList.remove('active');
                });
                
                if (index >= 0 && index < textBlocks.length) {
                    document.getElementById(textBlocks[index]).classList.add('active');
                }
                
                prevButton.disabled = index === 0;
                nextButton.disabled = index === textBlocks.length - 1;
                currentTextIndex = index;
            }
            
            function showPopup() {
                popupOverlay.style.display = 'flex';
                currentTextIndex = 0;
                showTextBlock(0);
            }
            
            function hidePopup() {
                popupOverlay.style.display = 'none';
            }
            
            addTouchAndClickListener(popupClose, hidePopup);
            addTouchAndClickListener(infoTrigger, showPopup);
            
            addTouchAndClickListener(prevButton, () => {
                if (currentTextIndex > 0) {
                    showTextBlock(currentTextIndex - 1);
                }
            });
            
            addTouchAndClickListener(nextButton, () => {
                if (currentTextIndex < textBlocks.length - 1) {
                    showTextBlock(currentTextIndex + 1);
                }
            });
            
            popupOverlay.addEventListener('click', (e) => {
                if (e.target === popupOverlay) {
                    hidePopup();
                }
            });
            
            popupOverlay.addEventListener('touchend', (e) => {
                if (e.target === popupOverlay) {
                    e.preventDefault();
                    hidePopup();
                }
            });
            
            // Demo state
            let waveformType = 'triangle'; // 'triangle' or 'sawtooth'
            let offset = 0; // -1 to 1
            let sliderPosition = 0.5; // 0 to 1
            
            // Canvas variables
            let width = canvas.width;
            let height = canvas.height;
            let centerY = height / 2;
            let centerX = width / 2;
            let amplitude = height * 0.25; // Changed from 0.35 to 0.25 for 1/2 distance
            
            window.addEventListener('resize', () => {
                width = canvas.width;
                height = canvas.height;
                centerY = height / 2;
                centerX = width / 2;
                amplitude = height * 0.25; // Maintain 1/2 distance on resize
            });
            
            // Slider functionality
            let isDragging = false;
            
            function updateSliderPosition(clientY) {
                const rect = sliderTrack.getBoundingClientRect();
                const relativeY = clientY - rect.top;
                const trackHeight = rect.height;
                
                sliderPosition = Math.max(0, Math.min(1, relativeY / trackHeight));
                offset = (0.5 - sliderPosition) * 2; // Convert to -1 to 1 range
                
                const thumbTop = sliderPosition * 100;
                sliderThumb.style.top = thumbTop + '%';
            }
            
            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
                sliderThumb.classList.add('dragging');
                
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                updateSliderPosition(clientY);
            }
            
            function moveDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                updateSliderPosition(clientY);
            }
            
            function endDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                isDragging = false;
                sliderThumb.classList.remove('dragging');
            }
            
            // Slider event listeners
            sliderThumb.addEventListener('mousedown', startDrag);
            sliderThumb.addEventListener('touchstart', startDrag);
            sliderTrack.addEventListener('mousedown', startDrag);
            sliderTrack.addEventListener('touchstart', startDrag);
            
            document.addEventListener('mousemove', moveDrag);
            document.addEventListener('touchmove', moveDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            document.addEventListener('mouseleave', endDrag);
            
            // Waveform button
            addTouchAndClickListener(waveformButton, () => {
                waveformType = waveformType === 'triangle' ? 'sawtooth' : 'triangle';
            });
            
            // Waveform generation functions
            function getTriangleValue(x) {
                const cycles = 2;
                const phase = (x / width) * cycles;
                const cyclePhase = phase % 1;
                
                let value;
                if (cyclePhase < 0.5) {
                    value = cyclePhase * 4 - 1;
                } else {
                    value = 3 - cyclePhase * 4;
                }
                
                return value + offset;
            }
            
            function getSawtoothValue(x) {
                const cycles = 2;
                const phase = (x / width) * cycles;
                const cyclePhase = phase % 1;
                
                const value = cyclePhase * 2 - 1;
                return value + offset;
            }
            
            function getWaveformValue(x) {
                return waveformType === 'triangle' ? getTriangleValue(x) : getSawtoothValue(x);
            }
            
            function getRectifiedValue(x) {
                const inputValue = getWaveformValue(x);
                return Math.abs(inputValue);
            }
            
            function drawGrid() {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.75)';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.stroke();
            }
            
            function draw() {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                
                drawGrid();
                
                ctx.lineWidth = 2;
                
                // Draw input waveform (blue)
                ctx.strokeStyle = '#0080ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const inputValue = getWaveformValue(x);
                    const inputY = centerY - (inputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, inputY);
                    } else {
                        ctx.lineTo(x, inputY);
                    }
                }
                ctx.stroke();
                
                // Draw output waveform (purple with transparency)
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.7)'; // Added transparency
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const outputValue = getRectifiedValue(x);
                    const outputY = centerY - (outputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, outputY);
                    } else {
                        ctx.lineTo(x, outputY);
                    }
                }
                ctx.stroke();
                
                requestAnimationFrame(draw);
            }
            
            // Show popup on first load
            showPopup();
            
            // Start drawing
            draw();
        }

        // Flip Flop / Comparator Demo Code
        function initFlipFlopDemo() {
            const canvas = document.getElementById('ffOscilloscope');
            const ctx = canvas.getContext('2d');
            const trigButton = document.getElementById('ffTrigButton');
            const modeButton = document.getElementById('ffModeButton');
            const pageTitle = document.getElementById('ffPageTitle');
            const labelContainer = document.getElementById('ffLabelContainer');
            const controlsContainer = document.getElementById('ffControlsContainer');
            const ledContainer = document.getElementById('ffLedContainer');
            const threshSlider = document.getElementById('ffThreshSlider');
            const offsetSlider = document.getElementById('ffOffsetSlider');
            const threshThumb = document.getElementById('threshThumb');
            const offsetThumb = document.getElementById('offsetThumb');
            
            // LED elements
            const ledTrig = document.getElementById('ledTrig');
            const ledFlip = document.getElementById('ledFlip');
            const ledFlop = document.getElementById('ledFlop');
            
            // Responsive canvas sizing
            function setCanvasSize() {
                const container = canvas.parentElement;
                const extraSpace = 200; // Extra space for LEDs/sliders + labels
                const maxWidth = Math.min(800, window.innerWidth - extraSpace);
                const aspectRatio = 2;
                
                canvas.width = maxWidth;
                canvas.height = maxWidth / aspectRatio;
                
                // Update label container height to match canvas
                const labels = labelContainer;
                if (labels) {
                    labels.style.height = canvas.height + 'px';
                }
            }
            
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            // Popup system
            const popupOverlay = document.getElementById('ffPopupOverlay');
            const popupClose = document.getElementById('ffPopupClose');
            const infoTrigger = document.getElementById('ffInfoTrigger');
            const prevButton = document.getElementById('ffPrevButton');
            const nextButton = document.getElementById('ffNextButton');
            
            let popupMode = 'flipflop';
            let currentTextIndex = 0;
            let hasSeenFlipFlopPopup = false;
            let hasSeenComparatorPopup = false;
            
            const flipFlopTextBlocks = ['ffText1', 'ffText2'];
            const comparatorTextBlocks = ['compText1', 'compText2'];
            
            function showTextBlock(index) {
                document.querySelectorAll('#ffPopupOverlay .text-block').forEach(block => {
                    block.classList.remove('active');
                });
                
                const blocks = popupMode === 'flipflop' ? flipFlopTextBlocks : comparatorTextBlocks;
                if (index >= 0 && index < blocks.length) {
                    document.getElementById(blocks[index]).classList.add('active');
                }
                
                prevButton.disabled = index === 0;
                nextButton.disabled = index === blocks.length - 1;
                currentTextIndex = index;
            }
            
            function showPopup() {
                popupOverlay.style.display = 'flex';
                currentTextIndex = 0;
                showTextBlock(0);
            }
            
            function hidePopup() {
                popupOverlay.style.display = 'none';
                
                if (popupMode === 'flipflop') {
                    hasSeenFlipFlopPopup = true;
                } else {
                    hasSeenComparatorPopup = true;
                }
            }
            
            addTouchAndClickListener(popupClose, hidePopup);
            addTouchAndClickListener(infoTrigger, showPopup);
            
            addTouchAndClickListener(prevButton, () => {
                if (currentTextIndex > 0) {
                    showTextBlock(currentTextIndex - 1);
                }
            });
            
            addTouchAndClickListener(nextButton, () => {
                const maxIndex = (popupMode === 'flipflop' ? flipFlopTextBlocks.length : comparatorTextBlocks.length) - 1;
                if (currentTextIndex < maxIndex) {
                    showTextBlock(currentTextIndex + 1);
                }
            });
            
            popupOverlay.addEventListener('click', (e) => {
                if (e.target === popupOverlay) {
                    hidePopup();
                }
            });
            
            popupOverlay.addEventListener('touchend', (e) => {
                if (e.target === popupOverlay) {
                    e.preventDefault();
                    hidePopup();
                }
            });
            
            // Demo state
            let currentMode = 'flipflop';
            let time = 0;
            let flipState = true; // flip starts high
            let flopState = false; // flop starts low
            let triggerActive = false;
            let triggerTime = 0;
            const triggerDuration = 20;
            
            // Comparator state
            let threshold = 0; // -1 to 1
            let offset = 0; // -1 to 1
            let thresholdPosition = 0.5; // 0 to 1
            let offsetPosition = 0.5; // 0 to 1
            
            // Canvas variables
            let width = canvas.width;
            let height = canvas.height;
            let centerY = height / 2;
            let centerX = width / 2;
            let amplitude = height * 0.25;
            
            window.addEventListener('resize', () => {
                width = canvas.width;
                height = canvas.height;
                centerY = height / 2;
                centerX = width / 2;
                amplitude = height * 0.25;
            });
            
            const triggerEvents = [];
            let lastFlipTime = -1000;
            
            // Prevent double-firing on mobile
            let lastTrigClickTime = 0;
            const minClickInterval = 100;
            
            // Triangle wave function for comparator
            const triangleFreq = 0.002;
            
            function getTriangleValue(t) {
                const phase = (t * triangleFreq) % 1;
                let value;
                if (phase < 0.5) {
                    value = phase * 2;
                } else {
                    value = 2 - (phase * 2);
                }
                return (value - 0.5) * 2;
            }
            
            // Static triangle for comparator (2 cycles)
            function getStaticTriangleValue(x) {
                const cycles = 2;
                const phase = (x / width) * cycles;
                const cyclePhase = phase % 1;
                
                let value;
                if (cyclePhase < 0.5) {
                    value = cyclePhase * 4 - 1;
                } else {
                    value = 3 - cyclePhase * 4;
                }
                
                return value + offset;
            }
            
            function drawGrid() {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.75)';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.stroke();
            }
            
            // Slider functionality
            let isDraggingThresh = false;
            let isDraggingOffset = false;
            
            function updateThresholdPosition(clientY) {
                const rect = threshSlider.querySelector('.slider-track').getBoundingClientRect();
                const relativeY = clientY - rect.top;
                const trackHeight = rect.height;
                
                thresholdPosition = Math.max(0, Math.min(1, relativeY / trackHeight));
                threshold = (0.5 - thresholdPosition) * 2; // Convert to -1 to 1 range
                
                const thumbTop = thresholdPosition * 100;
                threshThumb.style.top = thumbTop + '%';
            }
            
            function updateOffsetPosition(clientY) {
                const rect = offsetSlider.querySelector('.slider-track').getBoundingClientRect();
                const relativeY = clientY - rect.top;
                const trackHeight = rect.height;
                
                offsetPosition = Math.max(0, Math.min(1, relativeY / trackHeight));
                offset = (0.5 - offsetPosition) * 2; // Convert to -1 to 1 range
                
                const thumbTop = offsetPosition * 100;
                offsetThumb.style.top = thumbTop + '%';
            }
            
            function startThreshDrag(e) {
                e.preventDefault();
                isDraggingThresh = true;
                threshThumb.classList.add('dragging');
                
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                updateThresholdPosition(clientY);
            }
            
            function startOffsetDrag(e) {
                e.preventDefault();
                isDraggingOffset = true;
                offsetThumb.classList.add('dragging');
                
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                updateOffsetPosition(clientY);
            }
            
            function moveDrag(e) {
                if (!isDraggingThresh && !isDraggingOffset) return;
                e.preventDefault();
                
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (isDraggingThresh) {
                    updateThresholdPosition(clientY);
                } else if (isDraggingOffset) {
                    updateOffsetPosition(clientY);
                }
            }
            
            function endDrag(e) {
                if (isDraggingThresh || isDraggingOffset) {
                    e.preventDefault();
                    isDraggingThresh = false;
                    isDraggingOffset = false;
                    threshThumb.classList.remove('dragging');
                    offsetThumb.classList.remove('dragging');
                }
            }
            
            // Add slider event listeners
            threshThumb.addEventListener('mousedown', startThreshDrag);
            threshThumb.addEventListener('touchstart', startThreshDrag);
            threshSlider.querySelector('.slider-track').addEventListener('mousedown', startThreshDrag);
            threshSlider.querySelector('.slider-track').addEventListener('touchstart', startThreshDrag);
            
            offsetThumb.addEventListener('mousedown', startOffsetDrag);
            offsetThumb.addEventListener('touchstart', startOffsetDrag);
            offsetSlider.querySelector('.slider-track').addEventListener('mousedown', startOffsetDrag);
            offsetSlider.querySelector('.slider-track').addEventListener('touchstart', startOffsetDrag);
            
            document.addEventListener('mousemove', moveDrag);
            document.addEventListener('touchmove', moveDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            document.addEventListener('mouseleave', endDrag);
            
            function switchMode() {
                if (currentMode === 'flipflop') {
                    currentMode = 'comparator';
                    popupMode = 'comparator';
                    pageTitle.textContent = 'Comparator Demonstration';
                    modeButton.textContent = 'Switch to Flip Flop Mode';
                    
                    labelContainer.innerHTML = `
                        <div class="label-input">input</div>
                        <div class="label-trig">threshold</div>
                        <div class="label-output">output</div>
                    `;
                    
                    // Hide LEDs, show sliders
                    ledContainer.style.display = 'none';
                    threshSlider.style.display = 'block';
                    offsetSlider.style.display = 'block';
                    
                    // Hide trigger button for comparator mode
                    trigButton.style.display = 'none';
                    
                    if (!hasSeenComparatorPopup) {
                        showPopup();
                    }
                    
                } else {
                    currentMode = 'flipflop';
                    popupMode = 'flipflop';
                    pageTitle.textContent = 'Flip Flop Clock Divider Demonstration';
                    modeButton.textContent = 'Switch to Comparator Mode';
                    
                    labelContainer.innerHTML = `
                        <div class="label-trig">trig</div>
                        <div class="label-input">flip</div>
                        <div class="label-output">flop</div>
                    `;
                    
                    // Show LEDs, hide sliders
                    ledContainer.style.display = 'flex';
                    threshSlider.style.display = 'none';
                    offsetSlider.style.display = 'none';
                    
                    // Show trigger button for flip flop mode
                    trigButton.style.display = 'block';
                }
            }
            
            function updateLEDs() {
                // Update trigger LED based on trigger events
                let isTriggerActive = false;
                const currentTime = Date.now();
                
                // Check if trigger is currently active
                if (triggerActive && (currentTime - triggerTime) < triggerDuration) {
                    isTriggerActive = true;
                }
                
                // Also check recent trigger events for LED display
                for (const event of triggerEvents) {
                    const timeSinceTrigger = time - event.time;
                    if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                        isTriggerActive = true;
                        break;
                    }
                }
                
                if (isTriggerActive) {
                    ledTrig.classList.add('active-blue');
                } else {
                    ledTrig.classList.remove('active-blue');
                }
                
                // Update flip and flop LEDs based on their states
                if (flipState) {
                    ledFlip.classList.add('active-cyan');
                } else {
                    ledFlip.classList.remove('active-cyan');
                }
                
                if (flopState) {
                    ledFlop.classList.add('active-purple');
                } else {
                    ledFlop.classList.remove('active-purple');
                }
            }
            
            function drawFlipFlopMode() {
                const currentTime = Date.now();
                
                if (triggerActive && (currentTime - triggerTime) < 16) {
                    // Only add trigger event and toggle states once per trigger
                    const triggerAlreadyProcessed = triggerEvents.some(event => 
                        Math.abs(event.time - time) < 2
                    );
                    
                    if (!triggerAlreadyProcessed) {
                        triggerEvents.push({
                            time: time,
                            duration: triggerDuration,
                            flipStateAfter: !flipState,  // Store the state after this trigger
                            flopStateAfter: !flopState
                        });
                        
                        // Toggle flip and flop states only once
                        flipState = !flipState;
                        flopState = !flopState;
                        lastFlipTime = time;
                    }
                    
                    // Clean up old events
                    const cutoffTime = time - width * 2;
                    triggerEvents.splice(0, triggerEvents.findIndex(event => event.time > cutoffTime));
                }
                
                if (triggerActive && (currentTime - triggerTime) > triggerDuration) {
                    triggerActive = false;
                }
                
                ctx.lineWidth = 2;
                
                // Draw trigger trace (blue)
                ctx.strokeStyle = '#0080ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    let triggerState = false;
                    for (const event of triggerEvents) {
                        const timeSinceTrigger = t - event.time;
                        if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                            triggerState = true;
                            break;
                        }
                    }
                    
                    const triggerY = triggerState ? (height * 0.2) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, triggerY);
                    } else {
                        ctx.lineTo(x, triggerY);
                    }
                }
                ctx.stroke();
                
                // Draw flip trace (cyan)
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    // Find the most recent trigger event before time t
                    let currentFlipState = true; // Initial state
                    
                    for (let i = triggerEvents.length - 1; i >= 0; i--) {
                        if (triggerEvents[i].time <= t) {
                            currentFlipState = triggerEvents[i].flipStateAfter;
                            break;
                        }
                    }
                    
                    // Logic high = 35% from top, Logic low = centerY (zero line)
                    const flipY = currentFlipState ? (height * 0.35) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, flipY);
                    } else {
                        ctx.lineTo(x, flipY);
                    }
                }
                ctx.stroke();
                
                // Draw flop trace (purple)
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const t = time + (x - centerX) * 2;
                    
                    // Find the most recent trigger event before time t
                    let currentFlopState = false; // Initial state
                    
                    for (let i = triggerEvents.length - 1; i >= 0; i--) {
                        if (triggerEvents[i].time <= t) {
                            currentFlopState = triggerEvents[i].flopStateAfter;
                            break;
                        }
                    }
                    
                    // Logic high = 35% from top, Logic low = centerY (zero line)
                    const flopY = currentFlopState ? (height * 0.35) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, flopY);
                    } else {
                        ctx.lineTo(x, flopY);
                    }
                }
                ctx.stroke();
                
                // Update LEDs
                updateLEDs();
            }
            
            function drawComparatorMode() {
                ctx.lineWidth = 2;
                
                // Draw input waveform (cyan)
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const inputValue = getStaticTriangleValue(x);
                    const inputY = centerY - (inputValue * amplitude);
                    
                    if (x === 0) {
                        ctx.moveTo(x, inputY);
                    } else {
                        ctx.lineTo(x, inputY);
                    }
                }
                ctx.stroke();
                
                // Draw threshold line (blue)
                ctx.strokeStyle = '#0080ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const threshY = centerY - (threshold * amplitude);
                ctx.moveTo(0, threshY);
                ctx.lineTo(width, threshY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw output trace (purple)
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const inputValue = getStaticTriangleValue(x);
                    const outputState = inputValue > threshold;
                    // Logic high = 35% from top, Logic low = centerY (zero line)
                    const outputY = outputState ? (height * 0.35) : centerY;
                    
                    if (x === 0) {
                        ctx.moveTo(x, outputY);
                    } else {
                        ctx.lineTo(x, outputY);
                    }
                }
                ctx.stroke();
            }
            
            function draw() {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                
                drawGrid();
                
                if (currentMode === 'flipflop') {
                    drawFlipFlopMode();
                    time += 1;
                } else {
                    drawComparatorMode();
                    // Comparator mode is static, no time increment
                }
                
                requestAnimationFrame(draw);
            }
            
            // Trigger button handler
            const trigHandler = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                const currentTime = Date.now();
                if (currentTime - lastTrigClickTime < minClickInterval) {
                    return;
                }
                lastTrigClickTime = currentTime;
                
                triggerActive = true;
                triggerTime = currentTime;
            };
            
            if ('ontouchstart' in window) {
                trigButton.addEventListener('touchstart', trigHandler);
            } else {
                trigButton.addEventListener('click', trigHandler);
            }
            
            modeButton.addEventListener('click', switchMode);
            modeButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                switchMode();
            });
            
            // Show initial popup
            showPopup();
            
            // Initialize LED states
            updateLEDs();
            
            // Start drawing
            draw();
        }
    </script>
</body>
</html>
