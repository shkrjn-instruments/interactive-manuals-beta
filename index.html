<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sample and Hold Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            align-items: flex-start;
            gap: 30px;
            margin-bottom: 30px;
            max-width: 1400px;
            width: 100%;
            justify-content: center;
        }

        .text-column {
            flex: none;
            width: 250px;
            font-size: 14px;
            line-height: 1.6;
            color: #ffffff;
            /* Hide text columns - we'll use popups instead */
            display: none;
        }

        .text-column strong {
            font-weight: bold;
        }

        .oscilloscope-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 2;
        }

        .container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .labels {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 400px;
            font-size: 16px;
            font-weight: bold;
        }

        .label-input {
            color: #00ffff;
        }

        .label-trig {
            color: #0080ff;
        }

        .label-trig-orange {
            color: #ff8800;
        }

        .label-output {
            color: #ff00ff;
        }

        .label-output-yellow {
            color: #ffff00;
        }

        canvas {
            background-color: #000000;
            border: 2px solid #444444;
            border-radius: 4px;
        }

        .controls {
            position: relative;
            width: 800px;
            height: 60px;
            margin: 0 auto;
            margin-bottom: 20px;
        }

        .button {
            background-color: #0080ff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            /* Prevent text selection on touch devices */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts on iOS */
            -webkit-touch-callout: none;
            /* Prevent tap highlighting */
            -webkit-tap-highlight-color: transparent;
        }

        .button:hover {
            background-color: #0099ff;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
            background-color: #0066cc;
        }

        .smpl-button {
            position: absolute;
            top: 0;
            left: 365px;
            transform: translateX(-50%);
        }

        .track-button {
            position: absolute;
            top: 0;
            left: 515px;
            transform: translateX(-50%);
        }

        .track-button:hover {
            background-color: #0099ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .track-button:active {
            transform: translateX(-50%) translateY(0);
            background-color: #0066cc;
        }

        .smpl-button:hover {
            background-color: #0099ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .smpl-button:active {
            transform: translateX(-50%) translateY(0);
            background-color: #0066cc;
        }

        .duo-button {
            background-color: #8800ff;
            position: absolute;
            top: 0;
            left: 439px;
            transform: translateX(-50%);
        }

        .duo-button:hover {
            background-color: #9922ff;
            transform: translateX(-50%) translateY(-1px);
        }

        .duo-button:active {
            background-color: #6600cc;
            transform: translateX(-50%) translateY(0);
        }

        .mode-controls {
        position: relative; /* or absolute */
        left: 138px;        /* Position center at 400px (or whatever X coordinate you want) */
        transform: translateX(-50%); /* Shift button left by half its width */
        margin-top: 20px;
        }

        .mode-button {
            background-color: #444444;
            padding: 10px 20px;
            font-size: 14px;
        }

        .mode-button:hover {
            background-color: #555555;
        }

        .mode-button:active {
            background-color: #333333;
        }

        .title {
            margin-bottom: 30px;
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            width: 100%;
            max-width: 800px; /* Match oscilloscope width */
            margin-left: auto;
            margin-right: auto;
        }

        /* Responsive title sizing for mobile */
        @media (max-width: 768px) {
            .title {
                font-size: 20px;
                margin-bottom: 20px;
                padding: 0 10px; /* Add some side padding on mobile */
            }
        }

        /* Popup System */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup-window {
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffffff;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80%;
            padding: 30px;
            position: relative;
            overflow-y: auto;
        }

        .popup-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .popup-close:hover {
            color: #ff4444;
        }

        .popup-content {
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .popup-content strong {
            font-weight: bold;
        }

        .popup-navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .popup-nav-button {
            background-color: #444444;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.1s;
            font-family: 'Courier New', monospace;
        }

        .popup-nav-button:hover {
            background-color: #555555;
            transform: translateY(-1px);
        }

        .popup-nav-button:active {
            transform: translateY(0);
            background-color: #333333;
        }

        .popup-nav-button:disabled {
            background-color: #222222;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        .info-trigger {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            text-decoration: underline;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            z-index: 100;
            display: none;
        }

        .info-trigger:hover {
            color: #00ffff;
        }

        /* Text block styles */
        .text-block {
            display: none;
        }

        .text-block.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="title" id="pageTitle">Sample/Track and Hold Demonstration</div>
    
    <div class="main-container" id="mainContainer">
        <div class="oscilloscope-section">
            <div class="container">
                <div class="labels" id="labelContainer">
                    <div class="label-input">input</div>
                    <div class="label-trig">trig</div>
                    <div class="label-output">output</div>
                </div>
                
                <canvas id="oscilloscope" width="800" height="400"></canvas>
            </div>
            
            <div class="controls" id="controlsContainer">
                <button class="button smpl-button" id="trigButton">SMPL</button>
                <button class="button track-button" id="trackButton">TRACK</button>
            </div>
            
            <div class="mode-controls">
                <button class="button mode-button" id="modeButton">Switch to Duophonic Mode</button>
            </div>
        </div>
    </div>

    <!-- Info trigger -->
    <div class="info-trigger" id="infoTrigger">info</div>

    <!-- Popup System -->
    <div class="popup-overlay" id="popupOverlay">
        <div class="popup-window">
            <button class="popup-close" id="popupClose">Ã—</button>
            <div class="popup-content">
                <!-- Single Mode Text Blocks -->
                <div class="text-block active" id="singleText1">
                    <p>Think of a sample and hold as an analog memory circuit.</p>
                    <p>There is a signal input, trigger input, and signal output. When a trigger is applied to the trigger input, the instantaneous level of the input voltage is relayed to the signal output. This voltage is held until another trigger is received, which causes the process to repeat. A sample and hold is a great way to turn smooth and continuous modulation into stepwise modulation.</p>
                    <p>Click the <strong>smpl</strong> button and watch the purple output trace.</p>
                </div>
                
                <div class="text-block" id="singleText2">
                    <p>A track and hold responds to gates rather than triggers.</p>
                    <p>When a gate high is applied to the trigger input, the signal output will perfectly follow the signal input. When the gate goes low, the output signal will hold its most recent value until another trigger or gate is applied to the trigger input.</p>
                    <p>Click and hold the <strong>track</strong> button and watch the purple output trace. Notice the return back to sample and hold behavior after its release.</p>
                </div>
                
                <div class="text-block" id="singleText3">
                    <p>Combining both of these functions into one module allows for dynamic modulation by switching between stepwise and smooth modulation.</p>
                </div>

                <!-- Duophonic Mode Text Blocks -->
                <div class="text-block" id="duoText1">
                    <p>Duophonic Distribution combines two sample and holds and allows them to be triggered in an alternating manner.</p>
                    <p>This allows two distinct, but related, modulation sources to be derived from the same input signal. It can also be used to create true two voice polyphony by splitting a single pitch CV sequence between two oscillators.</p>
                </div>
                
                <div class="text-block" id="duoText2">
                    <p>Click the <strong>Duo</strong> button and watch the two output traces adjust in an alternating manner. To mimic this behavior IRL, apply a gate to the input of Duophonic Distribution's Flip Flop style clock divider.</p>
                </div>
            </div>
            
            <div class="popup-navigation">
                <button class="popup-nav-button" id="prevButton" disabled><< prev</button>
                <button class="popup-nav-button" id="nextButton">next >></button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('oscilloscope');
        const ctx = canvas.getContext('2d');
        const trigButton = document.getElementById('trigButton');
        const trackButton = document.getElementById('trackButton');
        const modeButton = document.getElementById('modeButton');
        const pageTitle = document.getElementById('pageTitle');
        const labelContainer = document.getElementById('labelContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        
        // Popup system elements
        const popupOverlay = document.getElementById('popupOverlay');
        const popupClose = document.getElementById('popupClose');
        const infoTrigger = document.getElementById('infoTrigger');
        const prevButton = document.getElementById('prevButton');
        const nextButton = document.getElementById('nextButton');
        
        // Popup state
        let popupMode = 'single';
        let currentTextIndex = 0;
        let hasSeenSinglePopup = false;
        let hasSeenDuoPopup = false;
        
        // Single mode text blocks
        const singleTextBlocks = ['singleText1', 'singleText2', 'singleText3'];
        // Duo mode text blocks  
        const duoTextBlocks = ['duoText1', 'duoText2'];
        
        // Store event listeners for cleanup
        let currentEventListeners = {
            trigButton: null,
            trackButton: null,
            duoButton: null,
            trackMouseUp: null,
            trackMouseLeave: null,
            trackTouchEnd: null
        };
        
        function showTextBlock(index) {
            // Hide all text blocks
            document.querySelectorAll('.text-block').forEach(block => {
                block.classList.remove('active');
            });
            
            // Show current text block based on mode
            const blocks = popupMode === 'single' ? singleTextBlocks : duoTextBlocks;
            if (index >= 0 && index < blocks.length) {
                document.getElementById(blocks[index]).classList.add('active');
            }
            
            // Update navigation buttons
            prevButton.disabled = index === 0;
            nextButton.disabled = index === blocks.length - 1;
            currentTextIndex = index;
        }
        
        function showPopup() {
            popupOverlay.style.display = 'flex';
            infoTrigger.style.display = 'none';
            
            // Reset to first text block for current mode
            currentTextIndex = 0;
            showTextBlock(0);
        }
        
        function hidePopup() {
            popupOverlay.style.display = 'none';
            infoTrigger.style.display = 'block';
            
            // Mark as seen
            if (popupMode === 'single') {
                hasSeenSinglePopup = true;
            } else {
                hasSeenDuoPopup = true;
            }
        }
        
        // Popup event listeners
        popupClose.addEventListener('click', hidePopup);
        infoTrigger.addEventListener('click', showPopup);
        
        prevButton.addEventListener('click', () => {
            if (currentTextIndex > 0) {
                showTextBlock(currentTextIndex - 1);
            }
        });
        
        nextButton.addEventListener('click', () => {
            const maxIndex = (popupMode === 'single' ? singleTextBlocks.length : duoTextBlocks.length) - 1;
            if (currentTextIndex < maxIndex) {
                showTextBlock(currentTextIndex + 1);
            }
        });
        
        // Close popup when clicking outside
        popupOverlay.addEventListener('click', (e) => {
            if (e.target === popupOverlay) {
                hidePopup();
            }
        });
        
        let currentMode = 'single';
        let time = 0;
        let sampledValue = 0;
        let sampledValue1 = 0;
        let sampledValue2 = 0;
        let triggerActive = false;
        let triggerActive1 = false;
        let triggerActive2 = false;
        let triggerTime = 0;
        let triggerTime1 = 0;
        let triggerTime2 = 0;
        let trackActive = false;
        let alternateFlag = true;
        const triggerDuration = 12.5;
        
        const width = canvas.width;
        const height = canvas.height;
        const centerY = height / 2;
        const centerX = width / 2;
        
        const triangleFreq = 0.002;
        const amplitude = height * 0.25;
        
        const triggerEvents = [];
        const trackEvents = [];
        const triggerEvents1 = [];
        const triggerEvents2 = [];
        let currentSampledValue = 0;
        let lastTriggerTime = -1000;
        let trackStartTime = -1000;
        
        // Prevent double-firing on mobile
        let lastDuoClickTime = 0;
        const minClickInterval = 100; // Minimum time between clicks in ms
        
        function getTriangleValue(t) {
            const phase = (t * triangleFreq) % 1;
            let value;
            if (phase < 0.5) {
                value = phase * 2;
            } else {
                value = 2 - (phase * 2);
            }
            return (value - 0.5) * 2;
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(128, 128, 128, 0.75)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        // Clean up function to remove all event listeners
        function cleanupEventListeners() {
            // Remove global event listeners
            if (currentEventListeners.trackMouseUp) {
                document.removeEventListener('mouseup', currentEventListeners.trackMouseUp);
                currentEventListeners.trackMouseUp = null;
            }
            if (currentEventListeners.trackMouseLeave) {
                document.removeEventListener('mouseleave', currentEventListeners.trackMouseLeave);
                currentEventListeners.trackMouseLeave = null;
            }
            if (currentEventListeners.trackTouchEnd) {
                document.removeEventListener('touchend', currentEventListeners.trackTouchEnd);
                currentEventListeners.trackTouchEnd = null;
            }
        }
        
        function switchMode() {
            // Clean up any existing event listeners
            cleanupEventListeners();
            
            if (currentMode === 'single') {
                currentMode = 'duo';
                popupMode = 'duo';  // Update popup mode
                pageTitle.textContent = 'Duophonic Sample and Hold Demonstration';
                modeButton.textContent = 'Switch to Single Mode';
                
                labelContainer.innerHTML = `
                    <div class="label-input">input</div>
                    <div class="label-trig">trig 1</div>
                    <div class="label-trig-orange">trig 2</div>
                    <div class="label-output">output 1</div>
                    <div class="label-output-yellow">output 2</div>
                `;
                
                controlsContainer.innerHTML = `
                    <button class="button duo-button" id="duoButton">DUO</button>
                `;
                
                const duoButton = document.getElementById('duoButton');
                
                // Handler function for duo button
                const duoHandler = (e) => {
                    e.preventDefault();
                    
                    const currentTime = Date.now();
                    if (currentTime - lastDuoClickTime < minClickInterval) {
                        return; // Ignore rapid clicks
                    }
                    lastDuoClickTime = currentTime;
                    
                    if (alternateFlag) {
                        triggerActive1 = true;
                        triggerTime1 = currentTime;
                    } else {
                        triggerActive2 = true;
                        triggerTime2 = currentTime;
                    }
                    alternateFlag = !alternateFlag;
                };
                
                // Add both click and touch support
                duoButton.addEventListener('click', duoHandler);
                duoButton.addEventListener('touchstart', duoHandler);
                
                // Store reference for cleanup
                currentEventListeners.duoButton = duoHandler;
                
                // Show popup if not seen before
                if (!hasSeenDuoPopup) {
                    showPopup();
                }
                
            } else {
                currentMode = 'single';
                popupMode = 'single';  // Update popup mode
                pageTitle.textContent = 'Sample/Track and Hold Demonstration';
                modeButton.textContent = 'Switch to Duophonic Mode';
                
                labelContainer.innerHTML = `
                    <div class="label-input">input</div>
                    <div class="label-trig">trig</div>
                    <div class="label-output">output</div>
                `;
                
                controlsContainer.innerHTML = `
                    <button class="button smpl-button" id="trigButton">SMPL</button>
                    <button class="button track-button" id="trackButton">TRACK</button>
                `;
                
                const newTrigButton = document.getElementById('trigButton');
                const newTrackButton = document.getElementById('trackButton');
                
                // Trigger button handler
                const trigHandler = (e) => {
                    e.preventDefault();
                    triggerActive = true;
                    triggerTime = Date.now();
                };
                
                newTrigButton.addEventListener('click', trigHandler);
                newTrigButton.addEventListener('touchstart', trigHandler);
                
                // Track button handlers
                const trackStartHandler = (e) => {
                    e.preventDefault();
                    trackActive = true;
                    trackStartTime = time;
                    trackEvents.push({
                        startTime: time,
                        endTime: null
                    });
                };
                
                const trackEndHandler = (e) => {
                    if (e) e.preventDefault();
                    if (trackActive) {
                        trackActive = false;
                        if (trackEvents.length > 0) {
                            const currentEvent = trackEvents[trackEvents.length - 1];
                            if (currentEvent.endTime === null) {
                                currentEvent.endTime = time;
                                sampledValue = getTriangleValue(time);
                            }
                        }
                    }
                };
                
                newTrackButton.addEventListener('mousedown', trackStartHandler);
                newTrackButton.addEventListener('touchstart', trackStartHandler);
                
                // Global handlers for track end
                currentEventListeners.trackMouseUp = trackEndHandler;
                currentEventListeners.trackTouchEnd = trackEndHandler;
                currentEventListeners.trackMouseLeave = trackEndHandler;
                
                document.addEventListener('mouseup', currentEventListeners.trackMouseUp);
                document.addEventListener('touchend', currentEventListeners.trackTouchEnd);
                document.addEventListener('mouseleave', currentEventListeners.trackMouseLeave);
            }
        }
        
        function drawSingleMode() {
            const currentTime = Date.now();
            
            if (triggerActive && (currentTime - triggerTime) < 16) {
                triggerEvents.push({
                    time: time,
                    duration: triggerDuration
                });
                
                currentSampledValue = getTriangleValue(time);
                sampledValue = currentSampledValue;
                lastTriggerTime = time;
                
                const cutoffTime = time - width * 2;
                triggerEvents.splice(0, triggerEvents.findIndex(event => event.time > cutoffTime));
                trackEvents.splice(0, trackEvents.findIndex(event => event.startTime > cutoffTime));
            }
            
            if (triggerActive && (currentTime - triggerTime) > triggerDuration) {
                triggerActive = false;
            }
            
            ctx.lineWidth = 2;
            
            // Draw input waveform (cyan)
            ctx.strokeStyle = '#00ffff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                const inputValue = getTriangleValue(t);
                const inputY = centerY - (inputValue * amplitude);
                
                if (x === 0) {
                    ctx.moveTo(x, inputY);
                } else {
                    ctx.lineTo(x, inputY);
                }
            }
            ctx.stroke();
            
            // Draw trigger trace (blue)
            ctx.strokeStyle = '#0080ff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let triggerState = false;
                
                for (const event of triggerEvents) {
                    const timeSinceTrigger = t - event.time;
                    if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                        triggerState = true;
                        break;
                    }
                }
                
                if (!triggerState) {
                    for (const event of trackEvents) {
                        if (t >= event.startTime && (event.endTime === null || t <= event.endTime)) {
                            triggerState = true;
                            break;
                        }
                    }
                }
                
                const triggerY = triggerState ? (height / 3) : centerY;
                
                if (x === 0) {
                    ctx.moveTo(x, triggerY);
                } else {
                    ctx.lineTo(x, triggerY);
                }
            }
            ctx.stroke();
            
            // Draw output trace (magenta)
            ctx.strokeStyle = '#ff00ff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let outputValue = 0;
                
                let inTrackPeriod = false;
                let activeTrackEvent = null;
                for (const event of trackEvents) {
                    if (t >= event.startTime && (event.endTime === null || t <= event.endTime)) {
                        inTrackPeriod = true;
                        activeTrackEvent = event;
                        break;
                    }
                }
                
                if (inTrackPeriod && activeTrackEvent) {
                    if (t <= time) {
                        outputValue = getTriangleValue(t);
                    } else {
                        let preTrackValue = 0;
                        let mostRecentTime = -Infinity;
                        
                        for (const trigEvent of triggerEvents) {
                            if (trigEvent.time < activeTrackEvent.startTime && trigEvent.time > mostRecentTime) {
                                mostRecentTime = trigEvent.time;
                                preTrackValue = getTriangleValue(trigEvent.time);
                            }
                        }
                        
                        for (const prevTrackEvent of trackEvents) {
                            if (prevTrackEvent.endTime !== null && 
                                prevTrackEvent.endTime < activeTrackEvent.startTime && 
                                prevTrackEvent.endTime > mostRecentTime) {
                                mostRecentTime = prevTrackEvent.endTime;
                                preTrackValue = getTriangleValue(prevTrackEvent.endTime);
                            }
                        }
                        
                        outputValue = preTrackValue;
                    }
                } else {
                    let mostRecentTime = -Infinity;
                    let mostRecentValue = 0;
                    
                    for (const event of triggerEvents) {
                        if (event.time <= t && event.time > mostRecentTime) {
                            mostRecentTime = event.time;
                            mostRecentValue = getTriangleValue(event.time);
                        }
                    }
                    
                    for (const event of trackEvents) {
                        if (event.endTime !== null && event.endTime <= t && event.endTime > mostRecentTime) {
                            mostRecentTime = event.endTime;
                            mostRecentValue = getTriangleValue(event.endTime);
                        }
                    }
                    
                    outputValue = mostRecentValue;
                }
                
                const outputY = centerY - (outputValue * amplitude);
                
                if (x === 0) {
                    ctx.moveTo(x, outputY);
                } else {
                    ctx.lineTo(x, outputY);
                }
            }
            ctx.stroke();
        }
        
        function drawDuoMode() {
            const currentTime = Date.now();
            
            if (triggerActive1 && (currentTime - triggerTime1) < 16) {
                triggerEvents1.push({
                    time: time,
                    duration: triggerDuration
                });
                sampledValue1 = getTriangleValue(time);
                
                const cutoffTime = time - width * 2;
                triggerEvents1.splice(0, triggerEvents1.findIndex(event => event ? event.time > cutoffTime : true));
            }
            
            if (triggerActive2 && (currentTime - triggerTime2) < 16) {
                triggerEvents2.push({
                    time: time,
                    duration: triggerDuration
                });
                sampledValue2 = getTriangleValue(time);
                
                const cutoffTime = time - width * 2;
                triggerEvents2.splice(0, triggerEvents2.findIndex(event => event ? event.time > cutoffTime : true));
            }
            
            if (triggerActive1 && (currentTime - triggerTime1) > triggerDuration) {
                triggerActive1 = false;
            }
            if (triggerActive2 && (currentTime - triggerTime2) > triggerDuration) {
                triggerActive2 = false;
            }
            
            ctx.lineWidth = 2;
            
            // Draw input waveform (cyan)
            ctx.strokeStyle = '#00ffff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                const inputValue = getTriangleValue(t);
                const inputY = centerY - (inputValue * amplitude);
                
                if (x === 0) {
                    ctx.moveTo(x, inputY);
                } else {
                    ctx.lineTo(x, inputY);
                }
            }
            ctx.stroke();
            
            // Draw trigger trace 1 (blue)
            ctx.strokeStyle = '#0080ff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let triggerState1 = false;
                for (const event of triggerEvents1) {
                    const timeSinceTrigger = t - event.time;
                    if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                        triggerState1 = true;
                        break;
                    }
                }
                
                const triggerY1 = triggerState1 ? (height / 3) : centerY;
                
                if (x === 0) {
                    ctx.moveTo(x, triggerY1);
                } else {
                    ctx.lineTo(x, triggerY1);
                }
            }
            ctx.stroke();
            
            // Draw trigger trace 2 (orange)
            ctx.strokeStyle = '#ff8800';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let triggerState2 = false;
                for (const event of triggerEvents2) {
                    const timeSinceTrigger = t - event.time;
                    if (timeSinceTrigger >= 0 && timeSinceTrigger < event.duration) {
                        triggerState2 = true;
                        break;
                    }
                }
                
                const triggerY2 = triggerState2 ? (height / 3) : centerY;
                
                if (x === 0) {
                    ctx.moveTo(x, triggerY2);
                } else {
                    ctx.lineTo(x, triggerY2);
                }
            }
            ctx.stroke();
            
            // Draw output trace 1 (magenta)
            ctx.strokeStyle = '#ff00ff';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let outputValue1 = 0;
                for (let i = triggerEvents1.length - 1; i >= 0; i--) {
                    const event = triggerEvents1[i];
                    if (event.time <= t) {
                        outputValue1 = getTriangleValue(event.time);
                        break;
                    }
                }
                
                const outputY1 = centerY - (outputValue1 * amplitude);
                
                if (x === 0) {
                    ctx.moveTo(x, outputY1);
                } else {
                    ctx.lineTo(x, outputY1);
                }
            }
            ctx.stroke();
            
            // Draw output trace 2 (yellow)
            ctx.strokeStyle = '#ffff00';
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
                const t = time + (x - centerX) * 2;
                
                let outputValue2 = 0;
                for (let i = triggerEvents2.length - 1; i >= 0; i--) {
                    const event = triggerEvents2[i];
                    if (event.time <= t) {
                        outputValue2 = getTriangleValue(event.time);
                        break;
                    }
                }
                
                const outputY2 = centerY - (outputValue2 * amplitude);
                
                if (x === 0) {
                    ctx.moveTo(x, outputY2);
                } else {
                    ctx.lineTo(x, outputY2);
                }
            }
            ctx.stroke();
        }
        
        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            drawGrid();
            
            if (currentMode === 'single') {
                drawSingleMode();
            } else {
                drawDuoMode();
            }
            
            time += 1;
            requestAnimationFrame(draw);
        }
        
        // Initial event listeners
        const initialTrigHandler = (e) => {
            e.preventDefault();
            triggerActive = true;
            triggerTime = Date.now();
        };
        
        trigButton.addEventListener('click', initialTrigHandler);
        trigButton.addEventListener('touchstart', initialTrigHandler);
        
        const initialTrackStartHandler = (e) => {
            e.preventDefault();
            trackActive = true;
            trackStartTime = time;
            trackEvents.push({
                startTime: time,
                endTime: null
            });
        };
        
        const initialTrackEndHandler = (e) => {
            if (e) e.preventDefault();
            if (trackActive) {
                trackActive = false;
                if (trackEvents.length > 0) {
                    const currentEvent = trackEvents[trackEvents.length - 1];
                    if (currentEvent.endTime === null) {
                        currentEvent.endTime = time;
                        sampledValue = getTriangleValue(time);
                    }
                }
            }
        };
        
        trackButton.addEventListener('mousedown', initialTrackStartHandler);
        trackButton.addEventListener('touchstart', initialTrackStartHandler);
        
        // Store initial handlers
        currentEventListeners.trackMouseUp = initialTrackEndHandler;
        currentEventListeners.trackTouchEnd = initialTrackEndHandler;
        currentEventListeners.trackMouseLeave = initialTrackEndHandler;
        
        document.addEventListener('mouseup', currentEventListeners.trackMouseUp);
        document.addEventListener('touchend', currentEventListeners.trackTouchEnd);
        document.addEventListener('mouseleave', currentEventListeners.trackMouseLeave);
        
        modeButton.addEventListener('click', switchMode);
        
        // Show initial popup
        showPopup();
        
        draw();
    </script>
</body>
</html>
